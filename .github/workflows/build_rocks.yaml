# Copyright 2024 Canonical Ltd.
# See LICENSE file for licensing details.
name: Build images

on:
  workflow_call:
    inputs:
      owner:
        type: string
        description: Registry owner to push the built images
        default: ${{ github.repository_owner }}
      registry:
        type: string
        description: Registry to push the built images
        default: "ghcr.io"
      runs-on:
        type: string
        description: Image runner for building the images
        default: ubuntu-22.04
      trivy-image-config:
        type: string
        description: Trivy YAML configuration for image testing that is checked in as part of the repo
      working-directory:
        type: string
        description: The working directory for jobs
        default: "./"
      cache-action:
        type: string
        description: The cache action can either be "save", "restore", or "skip".
        default: restore
      multiarch-awareness:
        type: boolean
        description: Maintain the architecture labels on the container names
        default: false
      platform-labels:
        type: string
        description: |-
          JSON mapping of rockcraft arches to gh runner labels
          The key should be one of the platforms in rockcraft.yaml (amd64, arm64...)
          the values should be a list of labels to use in the runs-on field of a gh action
        default: '{}'
      enabled-ubuntu-pro-features:
        type: string
        description: |
          Comma separated list of Ubuntu Pro features to enable.
        default: ""
      rockcraft-revisions:
        type: string
        description: |-
          Pin the rockcraft snap revision -- per architecture

          JSON mapping of rockcraft revisions
          The key should be one of the platforms in rockcraft.yaml (amd64, arm64...)
          The values should be a revision
          If the key is missing for a discovered architecture, the revision will be ''

          Priority order for rockcraft version resolution (highest to lowest):
          1. .rockcraft-version.yaml next to the rockcraft.yaml file
          2. .rockcraft-version.yaml in parent directories (walking up the tree)
          3. .rockcraft-version.yaml at the repository root
          4. This workflow input (rockcraft-revisions)

          If a .rockcraft-version.yaml file specifies either a revision or channel
          for the architecture, it takes precedence and this input is ignored.
          If none is specified, it defaults to 'latest/stable'.
        default: '{}'
      arch-skipping-maximize-build-space:
        type: string
        description: |-
          Some gh runners cannot use the maximize-build-spaces action
          This config allows you skip that action on certain architectures.

          JSON list of rockcraft arches to skip the maximize-build-space action
          the values should be a rockcraft arch types which skip the maximize-build-space action

          example)
            arch-skipping-maximize-build-space: '["arm64"]'
        default: '[]'
      build-env:
        type: string
        description: |-
          JSON mapping of environment variables to set during the build process.
          Useful for configuring build tools like Go proxy settings.
          
          example)
            build-env: '{"GOPROXY": "https://proxy.golang.org,direct", "GOSUMDB": "sum.golang.org"}'
        default: '{}'
      enable-go-caching:
        type: boolean
        description: |-
          Enable or disable Go module and build caching.
          When enabled, Go dependencies and build artifacts are cached between workflow runs
          to reduce network requests and improve build reliability on self-hosted runners.
        default: true
    secrets:
      UBUNTU_PRO_TOKEN:
        required: false
        description: |
          Ubuntu Pro token to use for building rocks on Ubuntu Pro
          This is required if enabled-ubuntu-pro-features is set.
    outputs:
      images:
        description: List of images built
        value: ${{ jobs.get-rocks.outputs.images }}
      rock-metas:
        description: List of maps featuring the built {name, version, path, arch, image, variant}
        value: ${{ jobs.get-rocks.outputs.rock-metas }}
      changed-rock-metas:
        description: List of maps featuring the built that has changed {name, version, path, arch, image, variant}
        value: ${{ jobs.get-rocks.outputs.changed-rock-metas }}

jobs:
  get-rocks:
    name: Get rocks
    runs-on: ${{ inputs.runs-on }}
    outputs:
      rock-paths: ${{ steps.gen-rock-paths-and-images.outputs.rock-paths }}
      images: "${{ steps.gen-rock-paths-and-images.outputs.images }}"
      rock-metas: ${{ steps.gen-rock-paths-and-images.outputs.rock-metas }}
      changed-rock-metas: ${{ steps.gen-rock-paths-and-images.outputs.changed-rock-metas }}
    steps:
      - name: Validate inputs
        run: |
          if [ "${{ inputs.cache-action }}" != "save" ] && [ "${{ inputs.cache-action }}" != "restore" ] && [ "${{ inputs.cache-action }}" != "skip" ]; then
            echo "Invalid value for cache-action. It must be 'save', 'restore', or 'skip'"
            exit 1
          fi
      - uses: actions/checkout@v4.1.1
      - uses: dorny/paths-filter@v3
        id: changes
        with:
          list-files: 'json'
          filters: |
            rocks:
              - '**/rockcraft.yaml'
      - uses: actions/setup-node@v4
      - name: Install JavaScript dependencies
        run: npm install js-yaml
      - name: Generate rock paths and images
        id: gen-rock-paths-and-images
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const fs = require('fs')
            const path = require('path')
            const yaml = require('js-yaml')

            const inputs = ${{ toJSON(inputs) }}
            const workingDir = inputs['working-directory']
            const multiarch = inputs['multiarch-awareness']
            const rockcraftGlobber = await glob.create(
                path.join(workingDir, '**/rockcraft.yaml')
            )
            const rockPaths = []
            const images = []
            const rockMetas = []
            const changedMetas = []
            const defaultArch = 'amd64'
            const changes = ${{ toJSON(steps.changes) }}
            const changesPaths = JSON.parse(changes['outputs']['rocks_files'])
            const platformLabels = JSON.parse(inputs['platform-labels'])
            const rockcraftRevisions = JSON.parse(inputs['rockcraft-revisions'])
            const isPullRequest = ${{ github.event_name == 'pull_request' }}
            core.info(`Multiarch Awareness is ${multiarch ? "on" : "off"}`)

            async function detectVariant(rockcraftFile, allRockcraftFiles) {
                const dir = path.dirname(rockcraftFile)
                const parentDir = path.dirname(dir)
                const parentRockcraft = path.join(parentDir, 'rockcraft.yaml')
                if (allRockcraftFiles.includes(parentRockcraft)) {
                    return path.basename(dir)
                }
                return null
            }

            async function resolveRockcraftVersion(rockPath, arch) {
                let currentDir = rockPath === './' ? '.' : rockPath
                let proFeatures = null  // null means use workflow default

                while (currentDir && currentDir !== '..' && !currentDir.startsWith('..')) {
                    const versionFile = path.join(currentDir, '.rockcraft-version.yaml')
                    try {
                        const content = fs.readFileSync(versionFile, 'utf-8');
                        const config = yaml.load(content)
                        core.info(`found .rockcraft-version.yaml in ${currentDir}`)

                        // Read pro-features setting (only once from nearest file)
                        if (proFeatures === null && config['pro-features']) {
                            proFeatures = config['pro-features'];
                            core.info(`resolved pro-features: ${proFeatures}`)
                        }

                        const archConfig = (config.versions || []).find(v => v.architecture === arch);
                        if (archConfig) {
                            core.info(`resolved rockcraft version for ${arch}: revision=${archConfig.revision || ''}, channel=${archConfig.channel || ''}`)
                            return {
                                revision: archConfig.revision || '',
                                channel: archConfig.channel || '',
                                proFeatures: proFeatures
                            }
                        }
                    } catch (e) {
                        // File doesn't exist, continue searching up
                    }

                    const parentDir = path.dirname(currentDir)
                    if (parentDir === currentDir || parentDir === '.') {
                        break
                    }
                    currentDir = parentDir
                }

                return { revision: '', channel: '', proFeatures: proFeatures }
            }

            const allRockcraftFiles = await rockcraftGlobber.glob()

            for (const rockcraftFile of allRockcraftFiles) {
                const rockPath = path.relative('.', path.dirname(rockcraftFile)) || "./"
                core.info(`found rockcraft.yaml in ${rockPath}`)
                const fileHash = await glob.hashFiles(path.join(rockPath, '**'))

                const rockcraft = yaml.load(fs.readFileSync(rockcraftFile, 'utf-8'));
                const rockName = rockcraft.name;
                const rockVersion = rockcraft.version;

                const variant = await detectVariant(rockcraftFile, allRockcraftFiles)
                if (variant) {
                    core.info(`detected variant: ${variant} for ${rockName}`)
                }
                if (multiarch && rockcraft.platforms) {
                    const arches = Object.keys(rockcraft.platforms || {});
                    for (arch of arches) {
                        const image = `${{inputs.registry}}/${{inputs.owner}}/${rockName}:${fileHash}-${arch}`
                        core.info(`generate multi-arch image name: ${image}`)
                        images.push(image)

                        // Resolve rockcraft version: .rockcraft-version.yaml takes precedence over input
                        // Only fall back to workflow input if no revision or channel was found
                        const rockcraftVersionConfig = await resolveRockcraftVersion(rockPath, arch)
                        const foundVersionConfig = rockcraftVersionConfig.revision || rockcraftVersionConfig.channel
                        const rockcraftRevision = foundVersionConfig
                            ? rockcraftVersionConfig.revision
                            : (rockcraftRevisions[arch] || '')
                        const rockcraftChannel = rockcraftVersionConfig.channel || ''

                        const meta = {
                            name: rockName,
                            version: rockVersion,
                            path: rockPath,
                            arch: arch,
                            image: image,
                            variant: variant || '',
                            "rockcraft-revision": rockcraftRevision,
                            "rockcraft-channel": rockcraftChannel,
                            "pro-features": rockcraftVersionConfig.proFeatures,
                            "runs-on-labels": platformLabels[arch] || [inputs["runs-on"]]
                        }
                        rockMetas.push(meta)
                        const imageExists = (await exec.getExecOutput('docker', ['manifest', 'inspect', image], {ignoreReturnCode: true})).exitCode === 0
                        if (isPullRequest && (changesPaths.includes(`${rockPath}/rockcraft.yaml`) || !imageExists)) {
                            changedMetas.push(meta)
                        } else if (!isPullRequest) {
                            changedMetas.push(meta)
                        }
                    }
                } else {
                    const image = `${{inputs.registry}}/${{inputs.owner}}/${rockName}:${fileHash}`
                    core.info(`generate image name: ${image}`)
                    images.push(image)

                    // Resolve rockcraft version: .rockcraft-version.yaml takes precedence over input
                    // Only fall back to workflow input if no revision or channel was found
                    const rockcraftVersionConfig = await resolveRockcraftVersion(rockPath, defaultArch)
                    const foundVersionConfig = rockcraftVersionConfig.revision || rockcraftVersionConfig.channel
                    const rockcraftRevision = foundVersionConfig
                        ? rockcraftVersionConfig.revision
                        : (rockcraftRevisions[defaultArch] || '')
                    const rockcraftChannel = rockcraftVersionConfig.channel || ''

                    const meta = {
                        name: rockName,
                        version: rockVersion,
                        path: rockPath,
                        arch: defaultArch,
                        image: image,
                        variant: variant || '',
                        "rockcraft-revision": rockcraftRevision,
                        "rockcraft-channel": rockcraftChannel,
                        "pro-features": rockcraftVersionConfig.proFeatures,
                        "runs-on-labels": platformLabels[defaultArch] || [inputs["runs-on"]]
                    };
                    rockMetas.push(meta)
                    const imageExists = (await exec.getExecOutput('docker', ['manifest', 'inspect', image], {ignoreReturnCode: true})).exitCode === 0
                    if (isPullRequest && (changesPaths.includes(`${rockPath}/rockcraft.yaml`) || !imageExists)) {
                        changedMetas.push(meta)
                    } else if (!isPullRequest) {
                        changedMetas.push(meta)
                    }
                }
                rockPaths.push(rockPath)
            }
            core.setOutput('rock-metas', JSON.stringify(rockMetas))
            core.setOutput('changed-rock-metas', JSON.stringify(changedMetas))
            core.setOutput('rock-paths', JSON.stringify(rockPaths))
            core.setOutput('images', JSON.stringify(images))

  build-rocks:
    name: Build rock
    needs: [get-rocks]
    if: ${{ needs.get-rocks.outputs.changed-rock-metas != '[]' }}
    strategy:
      matrix:
        rock: ${{ fromJSON(needs.get-rocks.outputs.changed-rock-metas) }}
      fail-fast: false
    runs-on: ${{ matrix.rock.runs-on-labels }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Enable Ubuntu Pro
        if: inputs.enabled-ubuntu-pro-features != ''
        run: |
          sudo apt-get update
          sudo apt-get install -y ubuntu-advantage-tools
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # NOTE: Enable once staging is back
            # sudo sh -c 'echo "contract_url: https://contracts.staging.canonical.com" > /etc/ubuntu-advantage/uaclient.conf'
            # TOKEN=${{ secrets.UBUNTU_PRO_STAGING_TOKEN }}
            TOKEN=${{ secrets.UBUNTU_PRO_TOKEN }}
          else
            TOKEN=${{ secrets.UBUNTU_PRO_TOKEN }}
          fi
          sudo pro attach $TOKEN --no-auto-enable
      - name: Ensure LXD storage pools path
        run: |
          sudo mkdir -p /var/snap/lxd/common/lxd/storage-pools
      - uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0
      - name: Ensure tools on Runner
        run: |
          if ! which yq; then sudo snap install yq; fi
          echo "path to yq=$(which yq)"

      - name: Extract rock information
        run: |
          IMAGE_ARCH="${{ matrix.rock.arch }}"
          IMAGE_NAME="${{ matrix.rock.name }}"
          IMAGE_BASE=$(yq '.base' "${{ matrix.rock.path }}/rockcraft.yaml")
          IMAGE_BUILD_BASE=$(yq '.["build-base"] // .base' "${{ matrix.rock.path }}/rockcraft.yaml")
          IMAGE_REF=${{ matrix.rock.image }}
          INODE_NUM=$(ls -id ${{ matrix.rock.path }} | cut -f 1 -d " ")
          ROCKCRAFT_CONTAINER_NAME=rockcraft-$IMAGE_NAME-$IMAGE_ARCH-$INODE_NUM
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "IMAGE_BASE=$IMAGE_BASE" >> $GITHUB_ENV
          echo "IMAGE_BUILD_BASE=$IMAGE_BUILD_BASE" >> $GITHUB_ENV
          echo "IMAGE_REF=$IMAGE_REF" >> $GITHUB_ENV
          echo "IMAGE_ARCH=$IMAGE_ARCH" >> $GITHUB_ENV
          echo "ROCKCRAFT_CONTAINER_NAME=$ROCKCRAFT_CONTAINER_NAME" >> $GITHUB_ENV
      - name: Compute stable cache date
        run: |
          # Use a single, stable UTC date across all cache keys
          TODAY=$(date -u +%Y-%m-%d)
          echo "TODAY=$TODAY" >> $GITHUB_ENV
      - name: Generate rockcraft cache key
        run: |
          ROCKCRAFT_PATH="${{ matrix.rock.path }}"
          ROCKCRAFT_PATH="${ROCKCRAFT_PATH%/}"
          ROCKCRAFT_CACHE_KEY_BASE="$ROCKCRAFT_PATH/rockcraft-cache?name=${{ env.IMAGE_NAME }}&base=${{ env.IMAGE_BUILD_BASE }}&build-base=${{ env.IMAGE_BUILD_BASE }}"
          ROCK_CACHE_KEY_BASE="$ROCKCRAFT_PATH/${{ env.IMAGE_NAME }}.rock?filehash=${{ hashFiles(format('{0}/{1}', matrix.rock.path, '**')) }}"
          if [ "${{ inputs.multiarch-awareness }}" == "true" ]; then
            ROCKCRAFT_CACHE_KEY_BASE="${ROCKCRAFT_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
            ROCK_CACHE_KEY_BASE="${ROCK_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
          fi
          echo "ROCKCRAFT_CACHE_KEY=$ROCKCRAFT_CACHE_KEY_BASE&date=${TODAY}" >> $GITHUB_ENV
          echo 'ROCKCRAFT_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "$ROCKCRAFT_CACHE_KEY_BASE&date=$(date -u -d "$TODAY - $d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
          echo "ROCK_CACHE_KEY=$ROCK_CACHE_KEY_BASE&date=${TODAY}" >> $GITHUB_ENV
          echo 'ROCK_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "$ROCK_CACHE_KEY_BASE&date=$(date -u -d "$TODAY - $d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
      - name: Generate Go cache keys
        if: inputs.enable-go-caching == true
        run: |
          ROCKCRAFT_PATH="${{ matrix.rock.path }}"
          ROCKCRAFT_PATH="${ROCKCRAFT_PATH%/}"
          
          # Check if Rock uses Go
          if [ -f "${{ matrix.rock.path }}/go.mod" ]; then
            echo "GO_DETECTED=true" >> $GITHUB_ENV
            GOMOD_HASH=$(sha256sum "${{ matrix.rock.path }}/go.mod" | cut -d' ' -f1 | cut -c1-8)
            GOSUM_HASH=""
            if [ -f "${{ matrix.rock.path }}/go.sum" ]; then
              GOSUM_HASH=$(sha256sum "${{ matrix.rock.path }}/go.sum" | cut -d' ' -f1 | cut -c1-8)
            fi
            echo "GOMOD_HASH=$GOMOD_HASH" >> $GITHUB_ENV
            echo "GOSUM_HASH=$GOSUM_HASH" >> $GITHUB_ENV
          else
            echo "GO_DETECTED=false" >> $GITHUB_ENV
            GOMOD_HASH="nogomod"
            GOSUM_HASH="nogosum"
          fi
          
          # Generate Go module cache key
          GO_MOD_CACHE_KEY_BASE="$ROCKCRAFT_PATH/go-mod-cache?name=${{ env.IMAGE_NAME }}&gomod=${GOMOD_HASH}&gosum=${GOSUM_HASH}"
          if [ "${{ inputs.multiarch-awareness }}" == "true" ]; then
            GO_MOD_CACHE_KEY_BASE="${GO_MOD_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
          fi
          echo "GO_MOD_CACHE_KEY=${GO_MOD_CACHE_KEY_BASE}&date=${TODAY}" >> $GITHUB_ENV
          echo 'GO_MOD_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "${GO_MOD_CACHE_KEY_BASE}&date=$(date -u -d "$TODAY - $d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
          
          # Generate Go build cache key
          GO_BUILD_CACHE_KEY_BASE="$ROCKCRAFT_PATH/go-build-cache?name=${{ env.IMAGE_NAME }}&gomod=${GOMOD_HASH}&gosum=${GOSUM_HASH}"
          if [ "${{ inputs.multiarch-awareness }}" == "true" ]; then
            GO_BUILD_CACHE_KEY_BASE="${GO_BUILD_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
          fi
          echo "GO_BUILD_CACHE_KEY=${GO_BUILD_CACHE_KEY_BASE}&date=${TODAY}" >> $GITHUB_ENV
          echo 'GO_BUILD_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "${GO_BUILD_CACHE_KEY_BASE}&date=$(date -u -d "$TODAY - $d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
          
          echo "Go cache keys generated for Rock: ${{ env.IMAGE_NAME }}"
          echo "  Go module cache key: ${GO_MOD_CACHE_KEY_BASE}&date=${TODAY}"
          echo "  Go build cache key: ${GO_BUILD_CACHE_KEY_BASE}&date=${TODAY}"
      - name: Restore rock cache
        if: inputs.cache-action == 'restore'
        uses: actions/cache/restore@v4.2.0
        id: rock-cache
        with:
          path: ~/.rock-cache
          key: ${{ env.ROCK_CACHE_KEY }}
          restore-keys: ${{ env.ROCK_CACHE_ALT_KEYS }}
      - name: Restore rockcraft container cache
        if: steps.rock-cache.outputs.cache-hit != 'true' && inputs.cache-action == 'restore'
        uses: actions/cache/restore@v4.2.0
        id: rockcraft-cache
        with:
          path: ~/.rockcraft-cache/
          key: ${{ env.ROCKCRAFT_CACHE_KEY }}
          restore-keys: ${{ env.ROCKCRAFT_CACHE_ALT_KEYS }}
      - name: Restore Go module cache
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        uses: actions/cache/restore@v4.2.0
        id: go-mod-cache
        continue-on-error: true
        with:
          path: ~/.go-mod-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_MOD_CACHE_KEY }}
          restore-keys: ${{ env.GO_MOD_CACHE_ALT_KEYS }}
      - name: Log Go module cache status
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        run: |
          if [ "${{ steps.go-mod-cache.outputs.cache-hit }}" == "true" ]; then
            echo "✓ Go module cache hit for key: ${{ env.GO_MOD_CACHE_KEY }}"
          else
            echo "✗ Go module cache miss for key: ${{ env.GO_MOD_CACHE_KEY }}"
            echo "  Will download dependencies from Go proxy during build"
          fi
      - name: Restore Go build cache
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        uses: actions/cache/restore@v4.2.0
        id: go-build-cache
        continue-on-error: true
        with:
          path: ~/.go-build-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_BUILD_CACHE_KEY }}
          restore-keys: ${{ env.GO_BUILD_CACHE_ALT_KEYS }}
      - name: Log Go build cache status
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        run: |
          if [ "${{ steps.go-build-cache.outputs.cache-hit }}" == "true" ]; then
            echo "✓ Go build cache hit for key: ${{ env.GO_BUILD_CACHE_KEY }}"
          else
            echo "✗ Go build cache miss for key: ${{ env.GO_BUILD_CACHE_KEY }}"
            echo "  Will recompile Go packages during build"
          fi
      - name: Setup LXD
        uses: canonical/setup-lxd@v0.1.3
      - name: Import rockcraft container cache
        if: steps.rockcraft-cache.outputs.cache-hit == 'true'
        working-directory: ${{ inputs.working-directory }}
        run: |
          sudo lxc project create rockcraft -c features.images=false -c features.profiles=false
          sudo lxc --project rockcraft import ~/.rockcraft-cache/${{ env.IMAGE_NAME }}.tar ${{ env.ROCKCRAFT_CONTAINER_NAME }}
          find . -exec touch '{}' ';'
      - name: Setup rockcraft
        env:
          REVISION: ${{ matrix.rock.rockcraft-revision }}
          CHANNEL: ${{ matrix.rock.rockcraft-channel || 'latest/stable' }}
        run: |
          if [[ -n "$REVISION" ]]; then
            sudo snap install rockcraft --classic --revision "$REVISION"
          else
            sudo snap install rockcraft --classic --channel "$CHANNEL"
          fi
      - name: Create Go cache directories
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true'
        run: |
          mkdir -p ~/.go-mod-cache/${{ env.IMAGE_NAME }}
          mkdir -p ~/.go-build-cache/${{ env.IMAGE_NAME }}
          echo "Created Go cache directories:"
          echo "  Module cache: ~/.go-mod-cache/${{ env.IMAGE_NAME }}"
          echo "  Build cache: ~/.go-build-cache/${{ env.IMAGE_NAME }}"
      - name: Mount Go caches into LXD container
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && (steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save')
        continue-on-error: true
        run: |
          # Wait for container to be ready (it may be starting from cache import)
          for i in {1..30}; do
            if sudo lxc --project rockcraft info ${{ env.ROCKCRAFT_CONTAINER_NAME }} 2>/dev/null | grep -q "Status: Running\|Status: Stopped"; then
              echo "Container ${{ env.ROCKCRAFT_CONTAINER_NAME }} is ready"
              break
            fi
            echo "Waiting for container to be ready... ($i/30)"
            sleep 2
          done
          
          # Get absolute paths for cache directories
          GO_MOD_CACHE_PATH=$(readlink -f ~/.go-mod-cache/${{ env.IMAGE_NAME }})
          GO_BUILD_CACHE_PATH=$(readlink -f ~/.go-build-cache/${{ env.IMAGE_NAME }})
          
          # Add disk devices to mount Go caches
          echo "Mounting Go module cache: $GO_MOD_CACHE_PATH -> /root/go/pkg/mod"
          sudo lxc --project rockcraft config device add ${{ env.ROCKCRAFT_CONTAINER_NAME }} go-mod-cache disk \
            source="$GO_MOD_CACHE_PATH" \
            path=/root/go/pkg/mod || echo "Warning: Failed to mount Go module cache, continuing anyway"
          
          echo "Mounting Go build cache: $GO_BUILD_CACHE_PATH -> /root/.cache/go-build"
          sudo lxc --project rockcraft config device add ${{ env.ROCKCRAFT_CONTAINER_NAME }} go-build-cache disk \
            source="$GO_BUILD_CACHE_PATH" \
            path=/root/.cache/go-build || echo "Warning: Failed to mount Go build cache, continuing anyway"
          
          echo "✓ Go caches mounted into LXD container"
      - name: Build rock
        if: steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save'
        working-directory: ${{ matrix.rock.path }}
        env: ${{ fromJSON(inputs.build-env) }}
        run: |
          BUILD_CMD="sudo -E rockcraft pack"
          PRO_FEATURES="${{ matrix.rock.pro-features }}"

          if [[ "$PRO_FEATURES" != "disabled" ]]; then
            if [[ -z "$PRO_FEATURES" || "$PRO_FEATURES" == "null" ]]; then
              PRO_FEATURES="${{ inputs.enabled-ubuntu-pro-features }}"
            fi
            if [[ -n "$PRO_FEATURES" ]]; then
              BUILD_CMD="sudo -E rockcraft pack --pro=$PRO_FEATURES"
              echo "Using Ubuntu Pro features: $PRO_FEATURES"
            fi
          else
            echo "Pro features disabled for this rock"
          fi

          if [ "${{ inputs.enable-go-caching }}" == "true" ] && [ "${{ env.GO_DETECTED }}" == "true" ]; then
            export GOMODCACHE=/root/go/pkg/mod
            export GOCACHE=/root/.cache/go-build
            export GOPROXY=https://proxy.golang.org,direct
            export GOSUMDB=sum.golang.org
            echo "Go caching enabled with:"
            echo "  GOMODCACHE=$GOMODCACHE"
            echo "  GOCACHE=$GOCACHE"
            echo "  GOPROXY=$GOPROXY"
          else
            export GOPROXY=direct
          fi

          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Build attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"
            if $BUILD_CMD; then
              echo "✓ Build succeeded"
              break
            else
              EXIT_CODE=$?
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠ Build failed with exit code $EXIT_CODE, retrying in 10 seconds..."
                sleep 10
              else
                echo "✗ Build failed after $MAX_RETRIES attempts"
                exit $EXIT_CODE
              fi
            fi
          done
      - name: Generate rockcraft container cache
        if: inputs.cache-action == 'save'
        run: |
          mkdir -p ~/.rockcraft-cache
          mkdir -p ~/.rock-cache
          touch ~/.rock-cache/.gitkeep
          sudo lxc --project rockcraft export ${{ env.ROCKCRAFT_CONTAINER_NAME }} --compression none ~/.rockcraft-cache/${{ env.IMAGE_NAME }}.tar
      - name: Delete rockcraft container cache
        if: inputs.cache-action == 'save'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.ROCKCRAFT_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $ROCKCRAFT_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save rockcraft container cache
        if: inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        with:
          path: ~/.rockcraft-cache/
          key: ${{ env.ROCKCRAFT_CACHE_KEY }}
      - name: Delete rock cache
        if: inputs.cache-action == 'save'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.ROCK_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $ROCK_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save rock cache
        if: inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        with:
          path: ~/.rock-cache
          key: ${{ env.ROCK_CACHE_KEY }}
      - name: Delete Go module cache
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && inputs.cache-action == 'save'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deleting old Go module cache entries..."
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.GO_MOD_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $GO_MOD_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save Go module cache
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        continue-on-error: true
        with:
          path: ~/.go-mod-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_MOD_CACHE_KEY }}
      - name: Log Go module cache save
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && inputs.cache-action == 'save'
        run: |
          echo "✓ Saved Go module cache with key: ${{ env.GO_MOD_CACHE_KEY }}"
      - name: Delete Go build cache
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && inputs.cache-action == 'save'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deleting old Go build cache entries..."
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.GO_BUILD_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $GO_BUILD_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save Go build cache
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        continue-on-error: true
        with:
          path: ~/.go-build-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_BUILD_CACHE_KEY }}
      - name: Log Go build cache save
        if: inputs.enable-go-caching == true && env.GO_DETECTED == 'true' && inputs.cache-action == 'save'
        run: |
          echo "✓ Saved Go build cache with key: ${{ env.GO_BUILD_CACHE_KEY }}"
      - name: Upload rock to ${{ inputs.registry }}
        if: steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save'
        run: |
          /snap/rockcraft/current/bin/skopeo --insecure-policy copy oci-archive:$(ls "${{ matrix.rock.path }}"/*.rock) docker://$IMAGE_REF --dest-creds "${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}"
