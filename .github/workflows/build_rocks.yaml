# Copyright 2024 Canonical Ltd.
# See LICENSE file for licensing details.

# Build Rocks Workflow
#
# This reusable workflow builds OCI images (Rocks) using Rockcraft.
#
# Go Caching:
#   This workflow includes Go module and build caching to improve build reliability
#   and reduce network requests, especially on self-hosted runners.
#
#   Cache Behavior:
#   - Go module cache: Stores downloaded Go dependencies (~/.go-mod-cache)
#   - Go build cache: Stores compiled Go packages (~/.go-build-cache)
#   - Caches are isolated per Rock (by name and path) and per architecture
#   - Cache keys include go.mod and go.sum hashes for automatic invalidation
#
#   Cache Key Structure:
#   - {rock-path}/go-mod-cache?name={rock-name}&gomod={hash}&gosum={hash}&arch={arch}&date={YYYY-MM-DD}
#   - {rock-path}/go-build-cache?name={rock-name}&gomod={hash}&gosum={hash}&arch={arch}&date={YYYY-MM-DD}
#
#   Parallel Builds:
#   - For parallel builds (e.g., PR builds), use cache-action: restore
#   - This allows all jobs to read from cache without conflicts
#   - For sequential builds (e.g., main branch), use cache-action: save
#   - This updates caches with newly downloaded dependencies
#
#   Cache Size Considerations:
#   - GitHub Actions has a 10GB cache limit per repository
#   - Go module caches are typically 100-500MB per Rock
#   - Go build caches are typically 50-200MB per Rock
#   - Caches are automatically evicted after 7 days of no access
#
#   Disabling Go Caching:
#   - Set enable-go-caching: false to disable Go caching
#   - Set cache-action: skip to disable all caching (rockcraft + Go)

name: Build images

on:
  workflow_call:
    inputs:
      owner:
        type: string
        description: Registry owner to push the built images
        default: ${{ github.repository_owner }}
      registry:
        type: string
        description: Registry to push the built images
        default: "ghcr.io"
      runs-on:
        type: string
        description: Image runner for building the images
        default: ubuntu-22.04
      trivy-image-config:
        type: string
        description: Trivy YAML configuration for image testing that is checked in as part of the repo
      working-directory:
        type: string
        description: The working directory for jobs
        default: "./"
      cache-action:
        type: string
        description: The cache action can either be "save", "restore", or "skip".
        default: restore
      multiarch-awareness:
        type: boolean
        description: Maintain the architecture labels on the container names
        default: false
      platform-labels:
        type: string
        description: |-
          JSON mapping of rockcraft arches to gh runner labels
          The key should be one of the platforms in rockcraft.yaml (amd64, arm64...)
          the values should be a list of labels to use in the runs-on field of a gh action
        default: '{}'
      enabled-ubuntu-pro-features:
        type: string
        description: |
          Comma separated list of Ubuntu Pro features to enable.
        default: ""
      rockcraft-revisions:
        type: string
        description: |-
          Pin the rockcraft snap revision -- per architecture

          JSON mapping of rockcraft revisions
          The key should be one of the platforms in rockcraft.yaml (amd64, arm64...)
          The values should be a revision
          If the key is missing for a discovered architecture, the revision will be ''
        default: '{}'
      arch-skipping-maximize-build-space:
        type: string
        description: |-
          Some gh runners cannot use the maximize-build-spaces action
          This config allows you skip that action on certain architectures.

          JSON list of rockcraft arches to skip the maximize-build-space action
          the values should be a rockcraft arch types which skip the maximize-build-space action

          example)
            arch-skipping-maximize-build-space: '["arm64"]'
        default: '[]'
      build-env:
        type: string
        description: |-
          JSON mapping of environment variables to set during the build process.
          Useful for configuring build tools like Go proxy settings.
          
          example)
            build-env: '{"GOPROXY": "https://proxy.golang.org,direct", "GOSUMDB": "sum.golang.org"}'
        default: '{}'
      enable-go-caching:
        type: boolean
        description: |-
          Enable or disable Go module and build caching.
          When enabled, Go dependencies and build artifacts are cached between workflow runs
          to reduce network requests and improve build reliability on self-hosted runners.
        default: true
    secrets:
      UBUNTU_PRO_TOKEN:
        required: false
        description: |
          Ubuntu Pro token to use for building rocks on Ubuntu Pro
          This is required if enabled-ubuntu-pro-features is set.
    outputs:
      images:
        description: List of images built
        value: ${{ jobs.get-rocks.outputs.images }}
      rock-metas:
        description: List of maps featuring the built {name, version, path, arch, image}
        value: ${{ jobs.get-rocks.outputs.rock-metas }}
      changed-rock-metas:
        description: List of maps featuring the built that has changed {name, version, path, arch, image}
        value: ${{ jobs.get-rocks.outputs.changed-rock-metas }}

jobs:
  get-rocks:
    name: Get rocks
    runs-on: ${{ inputs.runs-on }}
    outputs:
      rock-paths: ${{ steps.gen-rock-paths-and-images.outputs.rock-paths }}
      images: "${{ steps.gen-rock-paths-and-images.outputs.images }}"
      rock-metas: ${{ steps.gen-rock-paths-and-images.outputs.rock-metas }}
      changed-rock-metas: ${{ steps.gen-rock-paths-and-images.outputs.changed-rock-metas }}
    steps:
      - name: Validate inputs
        run: |
          if [ "${{ inputs.cache-action }}" != "save" ] && [ "${{ inputs.cache-action }}" != "restore" ] && [ "${{ inputs.cache-action }}" != "skip" ]; then
            echo "Invalid value for cache-action. It must be 'save', 'restore', or 'skip'"
            exit 1
          fi
      - uses: actions/checkout@v4.1.1
      - uses: dorny/paths-filter@v3
        id: changes
        with:
          list-files: 'json'
          filters: |
            rocks:
              - '**/rockcraft.yaml'
      - name: Generate rock paths and images
        id: gen-rock-paths-and-images
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const path = require('path')
            const inputs = ${{ toJSON(inputs) }}
            const workingDir = inputs['working-directory']
            const multiarch = inputs['multiarch-awareness']
            const rockcraftGlobber = await glob.create(
                path.join(workingDir, '**/rockcraft.yaml')
            )
            const rockPaths = []
            const images = []
            const rockMetas = []
            const changedMetas = []
            const defaultArch = 'amd64'
            const changes = ${{ toJSON(steps.changes) }}
            const changesPaths = JSON.parse(changes['outputs']['rocks_files'])
            const platformLabels = JSON.parse(inputs['platform-labels'])
            const rockcraftRevisions = JSON.parse(inputs['rockcraft-revisions'])
            const isPullRequest = ${{ github.event_name == 'pull_request' }}
            core.info(`Multiarch Awareness is ${multiarch ? "on" : "off"}`)
            for (const rockcraftFile of await rockcraftGlobber.glob()) {
                const rockPath = path.relative('.', path.dirname(rockcraftFile)) || "./"
                core.info(`found rockcraft.yaml in ${rockPath}`)
                const fileHash = await glob.hashFiles(path.join(rockPath, '**'))
                const [rockName, rockVersion] = (
                    await exec.getExecOutput('yq', ['.name,.version', rockcraftFile])
                ).stdout.trim().split("\n")
                const platforms = (
                    await exec.getExecOutput('yq', ['.platforms | keys', '-o=json', rockcraftFile])
                ).stdout.trim()
                if (multiarch && platforms) {
                    const arches = JSON.parse(platforms)
                    for (arch of arches) {
                        const image = `${{inputs.registry}}/${{inputs.owner}}/${rockName}:${fileHash}-${arch}`
                        core.info(`generate multi-arch image name: ${image}`)
                        images.push(image)
                        const meta = {
                            name: rockName,
                            version: rockVersion,
                            path: rockPath,
                            arch: arch,
                            image: image,
                            "rockcraft-revision": rockcraftRevisions[arch] || '',
                            "runs-on-labels": platformLabels[arch] || [inputs["runs-on"]]
                        }
                        rockMetas.push(meta)
                        const imageExists = (await exec.getExecOutput('docker', ['manifest', 'inspect', image], {ignoreReturnCode: true})).exitCode === 0
                        if (isPullRequest && (changesPaths.includes(`${rockPath}/rockcraft.yaml`) || !imageExists)) {
                            changedMetas.push(meta)
                        } else if (!isPullRequest) {
                            changedMetas.push(meta)
                        }
                    }
                } else {
                    const image = `${{inputs.registry}}/${{inputs.owner}}/${rockName}:${fileHash}`
                    core.info(`generate image name: ${image}`)
                    images.push(image)
                    const meta = {
                        name: rockName,
                        version: rockVersion,
                        path: rockPath,
                        arch: defaultArch,
                        image: image,
                        "rockcraft-revision": rockcraftRevisions[defaultArch] || '',
                        "runs-on-labels": platformLabels[defaultArch] || [inputs["runs-on"]]
                    };
                    rockMetas.push(meta)
                    const imageExists = (await exec.getExecOutput('docker', ['manifest', 'inspect', image], {ignoreReturnCode: true})).exitCode === 0
                    if (isPullRequest && (changesPaths.includes(`${rockPath}/rockcraft.yaml`) || !imageExists)) {
                        changedMetas.push(meta)
                    } else if (!isPullRequest) {
                        changedMetas.push(meta)
                    }
                }
                rockPaths.push(rockPath)
            }
            core.setOutput('rock-metas', JSON.stringify(rockMetas))
            core.setOutput('changed-rock-metas', JSON.stringify(changedMetas))
            core.setOutput('rock-paths', JSON.stringify(rockPaths))
            core.setOutput('images', JSON.stringify(images))

  build-rocks:
    name: Build rock
    needs: [get-rocks]
    if: ${{ needs.get-rocks.outputs.changed-rock-metas != '[]' }}
    strategy:
      matrix:
        rock: ${{ fromJSON(needs.get-rocks.outputs.changed-rock-metas) }}
      fail-fast: false
    runs-on: ${{ matrix.rock.runs-on-labels }}
    permissions:
      contents: read
      packages: write
    steps:
      - name: Enable Ubuntu Pro
        if: inputs.enabled-ubuntu-pro-features != ''
        run: |
          sudo apt-get update
          sudo apt-get install -y ubuntu-advantage-tools
          sudo sh -c 'echo "contract_url: https://contracts.staging.canonical.com" > /etc/ubuntu-advantage/uaclient.conf'
          sudo pro attach ${{ secrets.UBUNTU_PRO_TOKEN }} --no-auto-enable
      - name: Ensure LXD storage pools path
        run: |
          sudo mkdir -p /var/snap/lxd/common/lxd/storage-pools
      - name: Maximize build space
        if: ${{ !contains(fromJson(inputs.arch-skipping-maximize-build-space), matrix.rock.arch) }}
        uses: easimon/maximize-build-space@v10
        with:
          root-reserve-mb: 2048
          temp-reserve-mb: 2048
          overprovision-lvm: 'true'
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          build-mount-path: "/var/snap/lxd/common/lxd/storage-pools"
          build-mount-path-ownership: "root:root"
      - uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0
      - name: Ensure tools on Runner
        run: |
          if ! which yq; then sudo snap install yq; fi
          echo "path to yq=$(which yq)"

      - name: Extract rock information
        run: |
          IMAGE_ARCH="${{ matrix.rock.arch }}"
          IMAGE_NAME="${{ matrix.rock.name }}"
          IMAGE_BASE=$(yq '.base' "${{ matrix.rock.path }}/rockcraft.yaml")
          IMAGE_BUILD_BASE=$(yq '.["build-base"] // .base' "${{ matrix.rock.path }}/rockcraft.yaml")
          IMAGE_REF=${{ matrix.rock.image }}
          INODE_NUM=$(ls -id ${{ matrix.rock.path }} | cut -f 1 -d " ")
          ROCKCRAFT_CONTAINER_NAME=rockcraft-$IMAGE_NAME-$IMAGE_ARCH-$INODE_NUM
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "IMAGE_BASE=$IMAGE_BASE" >> $GITHUB_ENV
          echo "IMAGE_BUILD_BASE=$IMAGE_BUILD_BASE" >> $GITHUB_ENV
          echo "IMAGE_REF=$IMAGE_REF" >> $GITHUB_ENV
          echo "IMAGE_ARCH=$IMAGE_ARCH" >> $GITHUB_ENV
          echo "ROCKCRAFT_CONTAINER_NAME=$ROCKCRAFT_CONTAINER_NAME" >> $GITHUB_ENV
      - name: Generate rockcraft cache key
        run: |
          ROCKCRAFT_PATH="${{ matrix.rock.path }}"
          ROCKCRAFT_PATH="${ROCKCRAFT_PATH%/}"
          ROCKCRAFT_CACHE_KEY_BASE="$ROCKCRAFT_PATH/rockcraft-cache?name=${{ env.IMAGE_NAME }}&base=${{ env.IMAGE_BUILD_BASE }}&build-base=${{ env.IMAGE_BUILD_BASE }}"
          ROCK_CACHE_KEY_BASE="$ROCKCRAFT_PATH/${{ env.IMAGE_NAME }}.rock?filehash=${{ hashFiles(format('{0}/{1}', matrix.rock.path, '**')) }}"
          if [ "${{ inputs.multiarch-awareness }}" == "true" ]; then
            ROCKCRAFT_CACHE_KEY_BASE="${ROCKCRAFT_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
            ROCK_CACHE_KEY_BASE="${ROCK_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
          fi
          echo "ROCKCRAFT_CACHE_KEY=$ROCKCRAFT_CACHE_KEY_BASE&date=$(date +%Y-%m-%d)" >> $GITHUB_ENV
          echo 'ROCKCRAFT_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "$ROCKCRAFT_CACHE_KEY_BASE&date=$(date -d"-$d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
          echo "ROCK_CACHE_KEY=$ROCK_CACHE_KEY_BASE=$(date +%Y-%m-%d)" >> $GITHUB_ENV
          echo 'ROCK_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "$ROCK_CACHE_KEY_BASE&date=$(date -d"-$d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
      - name: Generate Go cache keys
        if: inputs.enable-go-caching == true
        run: |
          ROCKCRAFT_PATH="${{ matrix.rock.path }}"
          ROCKCRAFT_PATH="${ROCKCRAFT_PATH%/}"
          
          # Check if Rock uses Go
          if [ -f "${{ matrix.rock.path }}/go.mod" ]; then
            echo "GO_DETECTED=true" >> $GITHUB_ENV
            GOMOD_HASH=$(sha256sum "${{ matrix.rock.path }}/go.mod" | cut -d' ' -f1 | cut -c1-8)
            GOSUM_HASH=""
            if [ -f "${{ matrix.rock.path }}/go.sum" ]; then
              GOSUM_HASH=$(sha256sum "${{ matrix.rock.path }}/go.sum" | cut -d' ' -f1 | cut -c1-8)
            fi
            echo "GOMOD_HASH=$GOMOD_HASH" >> $GITHUB_ENV
            echo "GOSUM_HASH=$GOSUM_HASH" >> $GITHUB_ENV
          else
            echo "GO_DETECTED=false" >> $GITHUB_ENV
            GOMOD_HASH="nogomod"
            GOSUM_HASH="nogosum"
          fi
          
          # Generate Go module cache key
          GO_MOD_CACHE_KEY_BASE="$ROCKCRAFT_PATH/go-mod-cache?name=${{ env.IMAGE_NAME }}&gomod=${GOMOD_HASH}&gosum=${GOSUM_HASH}"
          if [ "${{ inputs.multiarch-awareness }}" == "true" ]; then
            GO_MOD_CACHE_KEY_BASE="${GO_MOD_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
          fi
          echo "GO_MOD_CACHE_KEY=${GO_MOD_CACHE_KEY_BASE}&date=$(date +%Y-%m-%d)" >> $GITHUB_ENV
          echo 'GO_MOD_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "${GO_MOD_CACHE_KEY_BASE}&date=$(date -d"-$d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
          
          # Generate Go build cache key
          GO_BUILD_CACHE_KEY_BASE="$ROCKCRAFT_PATH/go-build-cache?name=${{ env.IMAGE_NAME }}&gomod=${GOMOD_HASH}&gosum=${GOSUM_HASH}"
          if [ "${{ inputs.multiarch-awareness }}" == "true" ]; then
            GO_BUILD_CACHE_KEY_BASE="${GO_BUILD_CACHE_KEY_BASE}&arch=${{ env.IMAGE_ARCH }}"
          fi
          echo "GO_BUILD_CACHE_KEY=${GO_BUILD_CACHE_KEY_BASE}&date=$(date +%Y-%m-%d)" >> $GITHUB_ENV
          echo 'GO_BUILD_CACHE_ALT_KEYS<<EOF' >> $GITHUB_ENV
          for d in {1..2}
            do echo "${GO_BUILD_CACHE_KEY_BASE}&date=$(date -d"-$d days" +%Y-%m-%d)" >> $GITHUB_ENV
          done
          echo 'EOF' >> $GITHUB_ENV
          
          echo "Go cache keys generated for Rock: ${{ env.IMAGE_NAME }}"
          echo "  Go module cache key: ${GO_MOD_CACHE_KEY_BASE}&date=$(date +%Y-%m-%d)"
          echo "  Go build cache key: ${GO_BUILD_CACHE_KEY_BASE}&date=$(date +%Y-%m-%d)"
      - name: Restore rock cache
        if: inputs.cache-action == 'restore'
        uses: actions/cache/restore@v4.2.0
        id: rock-cache
        with:
          path: ~/.rock-cache
          key: ${{ env.ROCK_CACHE_KEY }}
          restore-keys: ${{ env.ROCK_CACHE_ALT_KEYS }}
      - name: Restore rockcraft container cache
        if: steps.rock-cache.outputs.cache-hit != 'true' && inputs.cache-action == 'restore'
        uses: actions/cache/restore@v4.2.0
        id: rockcraft-cache
        with:
          path: ~/.rockcraft-cache/
          key: ${{ env.ROCKCRAFT_CACHE_KEY }}
          restore-keys: ${{ env.ROCKCRAFT_CACHE_ALT_KEYS }}
      - name: Restore Go module cache
        if: inputs.enable-go-caching == true && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        uses: actions/cache/restore@v4.2.0
        id: go-mod-cache
        continue-on-error: true
        with:
          path: ~/.go-mod-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_MOD_CACHE_KEY }}
          restore-keys: ${{ env.GO_MOD_CACHE_ALT_KEYS }}
      - name: Log Go module cache status
        if: inputs.enable-go-caching == true && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        run: |
          if [ "${{ steps.go-mod-cache.outputs.cache-hit }}" == "true" ]; then
            echo "✓ Go module cache hit for key: ${{ env.GO_MOD_CACHE_KEY }}"
          else
            echo "✗ Go module cache miss for key: ${{ env.GO_MOD_CACHE_KEY }}"
            echo "  Will download dependencies from Go proxy during build"
          fi
      - name: Restore Go build cache
        if: inputs.enable-go-caching == true && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        uses: actions/cache/restore@v4.2.0
        id: go-build-cache
        continue-on-error: true
        with:
          path: ~/.go-build-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_BUILD_CACHE_KEY }}
          restore-keys: ${{ env.GO_BUILD_CACHE_ALT_KEYS }}
      - name: Log Go build cache status
        if: inputs.enable-go-caching == true && (inputs.cache-action == 'restore' || inputs.cache-action == 'save')
        run: |
          if [ "${{ steps.go-build-cache.outputs.cache-hit }}" == "true" ]; then
            echo "✓ Go build cache hit for key: ${{ env.GO_BUILD_CACHE_KEY }}"
          else
            echo "✗ Go build cache miss for key: ${{ env.GO_BUILD_CACHE_KEY }}"
            echo "  Will recompile Go packages during build"
          fi
      - name: Setup LXD
        uses: canonical/setup-lxd@v0.1.3
      - name: Import rockcraft container cache
        if: steps.rockcraft-cache.outputs.cache-hit == 'true'
        working-directory: ${{ inputs.working-directory }}
        run: |
          sudo lxc project create rockcraft -c features.images=false -c features.profiles=false
          sudo lxc --project rockcraft import ~/.rockcraft-cache/${{ env.IMAGE_NAME }}.tar ${{ env.ROCKCRAFT_CONTAINER_NAME }}
          find . -exec touch '{}' ';'
      - name: Setup rockcraft with specific revision
        if: matrix.rock.rockcraft-revision != ''
        run: |
          sudo snap install rockcraft --classic --revision ${{ matrix.rock.rockcraft-revision }}
      - name: Setup rockcraft stable
        if: matrix.rock.rockcraft-revision == ''
        run: |
          sudo snap install rockcraft --classic --stable
      - name: Create Go cache directories
        if: inputs.enable-go-caching == true
        run: |
          mkdir -p ~/.go-mod-cache/${{ env.IMAGE_NAME }}
          mkdir -p ~/.go-build-cache/${{ env.IMAGE_NAME }}
          echo "Created Go cache directories:"
          echo "  Module cache: ~/.go-mod-cache/${{ env.IMAGE_NAME }}"
          echo "  Build cache: ~/.go-build-cache/${{ env.IMAGE_NAME }}"
      - name: Mount Go caches into LXD container
        if: inputs.enable-go-caching == true && (steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save')
        continue-on-error: true
        run: |
          # Wait for container to be ready (it may be starting from cache import)
          for i in {1..30}; do
            if sudo lxc --project rockcraft info ${{ env.ROCKCRAFT_CONTAINER_NAME }} 2>/dev/null | grep -q "Status: Running\|Status: Stopped"; then
              echo "Container ${{ env.ROCKCRAFT_CONTAINER_NAME }} is ready"
              break
            fi
            echo "Waiting for container to be ready... ($i/30)"
            sleep 2
          done
          
          # Get absolute paths for cache directories
          GO_MOD_CACHE_PATH=$(readlink -f ~/.go-mod-cache/${{ env.IMAGE_NAME }})
          GO_BUILD_CACHE_PATH=$(readlink -f ~/.go-build-cache/${{ env.IMAGE_NAME }})
          
          # Add disk devices to mount Go caches
          echo "Mounting Go module cache: $GO_MOD_CACHE_PATH -> /root/go/pkg/mod"
          sudo lxc --project rockcraft config device add ${{ env.ROCKCRAFT_CONTAINER_NAME }} go-mod-cache disk \
            source="$GO_MOD_CACHE_PATH" \
            path=/root/go/pkg/mod || echo "Warning: Failed to mount Go module cache, continuing anyway"
          
          echo "Mounting Go build cache: $GO_BUILD_CACHE_PATH -> /root/.cache/go-build"
          sudo lxc --project rockcraft config device add ${{ env.ROCKCRAFT_CONTAINER_NAME }} go-build-cache disk \
            source="$GO_BUILD_CACHE_PATH" \
            path=/root/.cache/go-build || echo "Warning: Failed to mount Go build cache, continuing anyway"
          
          echo "✓ Go caches mounted into LXD container"
      - name: Build rock with Pro features
        if: inputs.enabled-ubuntu-pro-features != '' && (steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save')
        working-directory: ${{ matrix.rock.path }}
        env: ${{ fromJSON(inputs.build-env) }}
        run: |
          # Configure Go environment variables
          if [ "${{ inputs.enable-go-caching }}" == "true" ]; then
            export GOMODCACHE=/root/go/pkg/mod
            export GOCACHE=/root/.cache/go-build
            export GOPROXY=https://proxy.golang.org,direct
            export GOSUMDB=sum.golang.org
            echo "Go caching enabled with:"
            echo "  GOMODCACHE=$GOMODCACHE"
            echo "  GOCACHE=$GOCACHE"
            echo "  GOPROXY=$GOPROXY"
          else
            export GOPROXY=direct
          fi
          sudo -E rockcraft pack --pro=${{ inputs.enabled-ubuntu-pro-features }}
      - name: Build rock
        if: inputs.enabled-ubuntu-pro-features == '' && (steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save')
        working-directory: ${{ matrix.rock.path }}
        env: ${{ fromJSON(inputs.build-env) }}
        run: |
          # Configure Go environment variables
          if [ "${{ inputs.enable-go-caching }}" == "true" ]; then
            export GOMODCACHE=/root/go/pkg/mod
            export GOCACHE=/root/.cache/go-build
            export GOPROXY=https://proxy.golang.org,direct
            export GOSUMDB=sum.golang.org
            echo "Go caching enabled with:"
            echo "  GOMODCACHE=$GOMODCACHE"
            echo "  GOCACHE=$GOCACHE"
            echo "  GOPROXY=$GOPROXY"
          else
            export GOPROXY=direct
          fi
          sudo -E rockcraft pack
      - name: Generate rockcraft container cache
        if: inputs.cache-action == 'save'
        run: |
          mkdir -p ~/.rockcraft-cache
          mkdir -p ~/.rock-cache
          touch ~/.rock-cache/.gitkeep
          sudo lxc --project rockcraft export ${{ env.ROCKCRAFT_CONTAINER_NAME }} --compression none ~/.rockcraft-cache/${{ env.IMAGE_NAME }}.tar
      - name: Delete rockcraft container cache
        if: inputs.cache-action == 'save'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.ROCKCRAFT_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $ROCKCRAFT_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save rockcraft container cache
        if: inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        with:
          path: ~/.rockcraft-cache/
          key: ${{ env.ROCKCRAFT_CACHE_KEY }}
      - name: Delete rock cache
        if: inputs.cache-action == 'save'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.ROCK_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $ROCK_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save rock cache
        if: inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        with:
          path: ~/.rock-cache
          key: ${{ env.ROCK_CACHE_KEY }}
      - name: Delete Go module cache
        if: inputs.enable-go-caching == true && inputs.cache-action == 'save'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deleting old Go module cache entries..."
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.GO_MOD_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $GO_MOD_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save Go module cache
        if: inputs.enable-go-caching == true && inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        continue-on-error: true
        with:
          path: ~/.go-mod-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_MOD_CACHE_KEY }}
      - name: Log Go module cache save
        if: inputs.enable-go-caching == true && inputs.cache-action == 'save'
        run: |
          echo "✓ Saved Go module cache with key: ${{ env.GO_MOD_CACHE_KEY }}"
      - name: Delete Go build cache
        if: inputs.enable-go-caching == true && inputs.cache-action == 'save'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deleting old Go build cache entries..."
          gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/caches?key=$(printf %s "${{ env.GO_BUILD_CACHE_KEY }}"|jq -sRr @uri) || :
          for key in $(echo $GO_BUILD_CACHE_ALT_KEYS)
            do gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/actions/caches?key=$(printf %s "$key"|jq -sRr @uri) || :
          done
      - name: Save Go build cache
        if: inputs.enable-go-caching == true && inputs.cache-action == 'save'
        uses: actions/cache/save@v4.2.0
        continue-on-error: true
        with:
          path: ~/.go-build-cache/${{ env.IMAGE_NAME }}/
          key: ${{ env.GO_BUILD_CACHE_KEY }}
      - name: Log Go build cache save
        if: inputs.enable-go-caching == true && inputs.cache-action == 'save'
        run: |
          echo "✓ Saved Go build cache with key: ${{ env.GO_BUILD_CACHE_KEY }}"
      - name: Upload rock to ${{ inputs.registry }}
        if: steps.rock-cache.outputs.cache-hit != 'true' || inputs.cache-action == 'save'
        run: |
          /snap/rockcraft/current/bin/skopeo --insecure-policy copy oci-archive:$(ls "${{ matrix.rock.path }}"/*.rock) docker://$IMAGE_REF --dest-creds "${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}"
